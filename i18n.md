# I18N

## 1️⃣ Folder Structure

```
i18n/
├─ en.json                 # root translations, loaded globally
├─ fr.json                  # root translations, loaded globally
├─ auth/                   # auth feature translations (lazy-loaded)
│   ├─ en.json
│   └─ fr.json
├─ dashboard/              # dashboard feature translations (lazy-loaded)
│   ├─ en.json
│   └─ fr.json
├─ notifications/          # notifications feature translations (lazy-loaded)
│   ├─ en.json
│   └─ fr.json
```

---

## 2️⃣ Root / Common Translations Example

### **i18n/en.json**

```json
{
  "APP_TITLE": "My Application",
  "BUTTON_OK": "OK",
  "BUTTON_CANCEL": "Cancel",
  "NAV_HOME": "Home",
  "NAV_DASHBOARD": "Dashboard",
  "NAV_LOGOUT": "Logout"
}
```

### **i18n/fr.json**

```json
{
  "app.title": "Mon Application",
  "button.ok": "OK",
  "button.cancel": "Annuler",
  "nav.home": "Accueil",
  "nav.dashboard": "Tableau de bord",
  "nav.logout": "Se Déconnecter"
}
```

- Loaded **once at app bootstrap**.
- Available everywhere without lazy-loading.

---

## 3️⃣ Feature Translations (Lazy-loaded)

### **auth/en.json**

```json
{
  "AUTH_LOGIN_TITLE": "Login",
  "AUTH_LOGIN_USERNAME": "Username",
  "AUTH_LOGIN_PASSWORD": "Password",
  "AUTH_LOGIN_SUBMIT": "Sign In",
  "AUTH_LOGIN_FORGOT": "Forgot password?"
}
```

### **auth/fr.json**

```json
{
  "login.title": "Connexion",
  "login.username": "Nom d'utilisateur",
  "login.password": "Mot de passe",
  "login.submit": "Se Connecter",
  "login.forgot": "Mot de passe oublié ?"
}
```

- Loaded **only when the auth feature/component is used**.
- Merges into the translations signal with root translations.

---

## 4️⃣ I18n Service (Option B)

```ts
import { Injectable, signal } from "@angular/core";

interface Translations {
  [key: string]: string;
}

@Injectable({ providedIn: "root" })
export class I18nService {
  private translations = signal<Translations>({});
  private currentLang = signal<string>("en");

  constructor() {
    this.loadRoot(); // load root translations at startup
  }

  private async loadRoot() {
    const lang = this.currentLang();
    const module = await import(`./${lang}.json`);
    this.translations.set(module.default);
  }

  async loadFeature(feature: string) {
    const lang = this.currentLang();
    try {
      const module = await import(`./${feature}/${lang}.json`);
      this.translations.update((t) => ({ ...t, ...module.default }));
    } catch (err) {
      console.warn(
        `Could not load i18n for feature ${feature} in ${lang}`,
        err
      );
    }
  }

  setLang(lang: string) {
    this.currentLang.set(lang);
    localStorage.setItem("lang", lang);
    this.loadRoot(); // reload root translations
  }

  t(key: string): string {
    return this.translations()[key] ?? key;
  }
}
```

---

✅ **Benefits of this approach**

- Root translations live **directly under `i18n/`** → simple and clear.
- Feature translations remain **lazy-loaded**, reducing bundle size.
- Works for **multi-app monorepo** with shared translations.
- Signals make all translations **reactive**.
